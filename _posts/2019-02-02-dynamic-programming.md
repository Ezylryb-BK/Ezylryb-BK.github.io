---
layout: post
title: 动态规划
subtitle: 啊 这篇有一、、长
gh-repo: Ezylryb-BK/Ezylryb-BK.github.io
gh-badge:
  - star
  - folk
  - follow
tags:
  - 动态规划
  - 算法导论
  - 算法
comments: true
published: true
image: /img/vein2.jpg
---

## why

为什么我们要进行动态规划呢？我们先来看看这一棵求解斐波那契数列的的递归树吧：

![1](/img/rec-tree.jpg)

我们发现，使用朴素的递归算法，我们会对同一个子问题（比如这里的f(6)重复求解了3次）求解多次，导致了效率的降低（而且规模越大由于重复计算的效率降低越为严重）

所以，我们期望找到这样一种算法，它对所有相关的子问题只计算一次，而且保持递归或循环的自然结构，这种算法就是动态规划算法。

动态规划和分治法的思想都是通过组合子问题的解来获得原问题的解，不过动态规划适用于子问题重叠（即子问题的解包含公共子子问题的解），而分治法适用于子问题互不相交的情境。

这里我想把三个算法稍微归纳一下：

|  |动态规划|分而治之|贪心算法|
|---|---|---|---|
|**适用**|适用于求解这样的最优化问题：具备最优子结构和子问题重叠的性质|适用于求解子问题互不相交的问题|适用于求解具有最优子结构的问题|
|**特点**|首先寻找子问题的最优解，然后在其中进行选择相关的子问题进行求解，求解了原问题的所有子问题的最优解，且每个子问题只求解一次|求解了原问题的所有子问题的解|首先做出局部的最优选择，然后求解选择出的子问题，并未求解所有可能的相关子问题|

这里解释一下提到的几个概念：

>**最优解：** 具有最优值（最大或最小值）的解是问题的一个最优解，问题可以有许多个最优解。

>**最优子结构：** 原问题的最优解由相关子问题的最优解组合而成，而且这些子问题可以独立求解（独立指的是子问题之间具有无关性）。

>**无关性：** 两个不同的子问题不共享资源，即：具有是同一个原问题的一个子问题的解不影响另一个子问题的解，但是我们不能混淆的是，可以由一个或几个子问题的解确定另外的子问题的解。

>**重叠性：** 同一子问题作为不同问题的子问题反复出现。

**值得注意的是：子问题的无关性和重叠性是不矛盾的。** 

另外，还有一些将要用到的概念也整理在这里吧，方便查找;

>**拓扑逆序**：即对任意子问题，直至它依赖的所有子问题均求解完，才会求解它

>**子问题间的依赖关系：** 子问题图中，x -> y 表示x依赖y，即自顶向下求解子问题x时需要直接递归调用自身来求解子问题y 。

>**出度：** 子问题图中对应顶点的度（出射边的数目），子问题的求解时间通常与其出度成正比。

>**备忘机制：**  维护一个表记录子问题的解（前提：已知所有可能的子问题参数/子问题空间，并能够在表项和子问题间建立起对应关系）

***

## How

>利用动态规划求解最优化问题的四个步骤：<br>
1. 刻画一个最优解的结构特征（即寻找具有最优子结构的建模方案，原问题分解成子问题）；<br>
2. 递归地定义最优解的值（推导递归式）；<br>
3. 采用自底向上的方法计算最优解的值（同时通过表维护一些信息以便构造最优解）；<br>
4. 构造最优解；

概念真是一个令人昏昏欲睡的东西，嘿，醒醒，那我们来看栗子叭...我们将尝试用动态规划解决经典的钢条切割问题。

>问题描述：钢条长度和切割长度均为整数，单独出售长度为i的钢条的价格为pi（已知），给定钢条长度n，求切割方案使收益最大化。

1. 我们对钢条进行建模，以钢条最左边为原点建立坐标，各可能的切割点坐标分别为0~n-1，在实际切割时，我们在任意坐标i处总可以选择切或不切。记切割成k段的最大收益为rk，我们发现

```math
r_k=\max ( p_k, r_1+r_{k-1}, r_2+r_{k-2}, ... ,r_{k-1}+r_1)
```

>公式打不出来，凑合着看吧。。。

(也可以用反证法证明) 原问题的最优解确实是由子问题的最优解组合成的，故其具有最优子结构。

2. 步骤一中的表达式可以简化为：

```math
r_k=\max_{1 \le i \le k} ( p_i+r_{k-i} )
```

这是一个定义原问题的解的递归式，可以理解为每一次递归都从左边切下长度为i的一段，之后保持左边不再切割，对右边剩下的钢铁采取同理的切割方案，每次递归都保证返回该次递归的子问题的最优解。

3. 自底向上地计算

这里，为了说明什么是自底向上，我们先给出一个对比：

 | |编写形式|顺序|是否保存子问题的解|特点|别名|证明方法|时间复杂度（以钢铁切割问题为例）|
 |---|---|---|---|---|---|---|---|
 自顶向下（朴素递归）|递归形式|递归的自然顺序|否|/|/|归纳法|O(2^n)|
 自顶向下（动态规划）|递归形式|递归的自然顺序，子问题图的拓扑顺序|是|计算一个子问题的解时首先检查是否保存过此解|深度优先搜索/带备忘的自顶向下|归纳法，反证法|O(n^2)
 自底向上（动态规划）|以嵌套的双重三重循环为主体|采用子问题的自然顺序，子问题图的拓扑逆序|是|求解r[j]时直接通过访问r[j-i]来实现|/|归纳法，反证法|O(n^2)，隐藏系数比自顶向下的小|

**算法1：朴素递归**

>界：n=0时返回0；<br>
规模变量： n=n to 0;<br>
第n次递归返回值：q(代表rn)<br>
>>递归体伪代码:
>>```C++
>>for i=1 to n
>>   q = max ( q , p[ i ]+f (n-i) )
>>```

**算法2：自顶向下动态规划**

>界：n=0时返回0；<br>
规模变量：n=n to 0;<br>
第n次递归返回值：r[n] (代表rn );
>>相对朴素递归做的优化：<br>
>>递归前开了数组r[n+1]，储存r1~rn，初始化为全-1（特别的值）；<br>
>>递归的第一条语句是检验r[k]，若r[k]已保存（r[k]>0）则直接返回，下一条语句才是界的检验；<br>
>递归体伪代码
>```C
>for i=1 to n
>r[n]=max ( r[n], p[i]+f(n-i) )
>```

**算法3：自底向上的动态规划**

>循环前：开数组r[n+1]，初始化为全0；<br>
外层循环：j=1 to n;(代表钢铁长度)<br>
内层循环：i=1 to j;<br>
>>内循环体伪代码：
>>```C
>>r[ j ] =max ( r[ j ] , p[ i ]+r[ j-i ] )
>>```

4. 重构最优解

那么我们需要回到第三步，在循环前额外开一个数组s[n+1]，s[ j ] 存放长度为j的钢条的切割方案中最优解对应的左边切割的第一段钢条的长度, 在内循环体中加入： ``` s[ j ] = i ; ```以保存最优解的信息，那么重构输出时我们便可以这样做：

```C
while n>0
    print s[n]
    n=n-s[n]
```

啊  接下来，这是一个子问题图（有向图）

![1](/img/pic.PNG)

其中，每个节点代表一个子问题，节点里的数字是该子问题的规模，有向边代表的是子问题最优解的依赖关系。
动态规划算法的运行时间通常与顶点和边的数量成线性关系。

>**[小结]发掘最优子结构的通用模式：**<br>
1. 证明问题最优解第一个组成部分是一个能产生一个或多个子问题的选择（比如选择分割点的位置）<br>
2. 假设第一步选择已是最优选择，并且假定已知最优选择方案<br>
3. 给定选择后，确定这次选择产生的子问题，保持刻画的子问题空间尽可能简单<br>
4. 反证法证明其具有最优子结构（原问题的最优解包含其子问题的最优解）

***

## 栗子们粗来玩

### 矩阵链完全括号化问题

>**问题描述**<br>
给定n个矩阵的链<A1, A2, ... , An>, 矩阵Ai的规模为p_{i-1} * p_i ,求完全括号化方案，使得计算乘积 A1\*A2\*A3...\*An 所需标量乘法次数最少。

understand the problem: 最优完全括号化方案其实就是最优计算顺序。记n为矩阵链的规模，那么可供选择的括号化方案数量：

![1](/img/math1.PNG)

1. **最优子结构**

对从Ai~Aj的链（ 记其结果矩阵为A_{i,j} ）,则对于其中任意一个分割点k（表示分割处在Ak和A_{k+1}）之间）, A_{i,j} 的最优解由 A_{i,k}, A_{k+1,j} 的最优解构成。<br>
tip: 反证法证明

2. **递归求解方案**

记m[i,j]为计算A_{i,j}所需标量乘法次数的最小值（即最优解的值），
k表示分割点位置（i <= k < j ）,则

![2](/img/math2.PNG)

注：矩阵Ai的大小是pi*p_{i+1}, 第三项表示的是A_{i,k}与A_{k+1,j}相乘的标量乘法次数。

3. **计算最优解的值-自底向上表格法**

{: .box-note}
**构建辅助表**<br>
m[n+1,n+1]保存最优解的值；(初始化为0)<br>
s[n+1,n+1]保存m[i,j]对应的最后一个分割点位置k；（初始化为0）

tip:分析依赖关系以确定外循环变量<br>
m[i,j]依赖于那些长度少于j-i+1的矩阵链的最优解，故求解顺序：按长度递增链求解，外循环变量：链长len；

伪代码实现：

```C++
len=2 to n
    i=1 to n-len+1
        j=i+len-1
       m[i,j]=sizeof(int)
           k=i to j-1
               m[i,j]=min( m[i,j], m[i,k]+m[k+1,j-1],p_{i-1}*p_k*p_j )
               s[i]=k
return m,s
```

4. 构造最优解

s[i,j]记录了A_{i,j}最优切割方案的最后一个分割点，由此逆过程推演查表即可；

伪代码(递归)实现：

```c++
Print-P ( s,i,j )
    if i==j
        print "A"i
    else print "("
        Print-P ( s,i,s[i,j] )
        Print-P ( s,s[i,j]+1,j )
        print ")"
```

### LCS(最长公共子序列)问题

>问题描述：求输入的两个序列Xm, Yn的最长共公共子序列。

1. **最优子结构**

记Zk是Xm, Yn 的LCS, 则Z_{k-1}一定是X_{m-1}, Y_{n-1} 的LCS;即：两个序列的LCS包含这两个序列的前缀的LCS。<br>
tip: 反证法+分类讨论（xm=yn和xm!=yn的情况）证明；

2. **递归定义式**

>**记号**<br>
Xi, Yj : 两个长度分别为 i, j 的序列；<br>
c [ i,j ]: 表示Xi和Yj的LCS的长度；<br>

![3](/img/math3.PNG)

3. **计算**

{: .box-note}
构造表:<br>
c[m+1, n+1]: LCS的长度；（初始化为0）<br>
b[m+1,n+1]: 记录子问题c[i,j]的最优解；（用特殊标记比如箭头字符标记该子问题是分类情况中的哪一类子问题）

伪代码：

```C
LCS(X,Y)
    for i=1 to m
        for j=1 to n
            if xi==yj
                c[i,j]=c[i-1,j-1]+1
                b[i,j]=" \ "
            else if c[i-1,j]>=c[i,j-1]
                c[i,j]=c[i-1,j]
                b[i,j]=" | "
            else
                c[i,j]=c[i,j-1]
                b[i,j]="—"
return c,b
```

4.重构最优解

伪代码：

```c++
Print-LCS(b,X,i,j)
    if i==0 || j==0
        return
    if b[i,j]=="\"
        Print-LCS(b,X,i-1,j-1)
    else if b[i,j]=="|"
        Print-LCS(b,X,i-1,j)
    else 
        Print-LCS(b,X,i,j-1)
```

***

### 0-1背包问题的一个栗子

这是LC上的一道中档题, [Ones an Zeroes](https://leetcode.com/problems/ones-and-zeroes/)

{: .box-note}
**问题描述：**<br>
In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.<br>
**Note:**<br>
The given numbers of 0s and 1s will both not exceed 100<br>
The size of given string array won't exceed 600.<br>

（意思就是说：一组由若干0和1构成的若干字符串，求：给定m个0，n个1，用这m个1和n个0最多能组成所给字符串集合中的的几个字符串。）

我的动态规划解决方案代码（beat 96.92%）：

```C++
class Solution {
public:
int findMaxForm ( vector<string>& strs, int m, int n) {
int a[m+1][n+1];
memset (a,0,sizeof(a) );
for (int i=0; i<strs.size(); i++) {
    int zero=0,one=0;
    string temp=strs[i];
for (int j=0;j<temp.size(); j++) {
    if (temp[j]=='0') {
        zero++;
    }else
    one++;
}
for (int p=m;p>=zero;p--) {
    for (int q=n;q>=one;q--) {
        a[p][q]=max (a[p][q],a[p-zero][q-one]+1);
    }
}
}
return a[m][n];
}
};
```

**分析：**

1. **最优子结构和递归定义式**

假定a[p][q]表示p个0，q个1能表示的集合中的最多字符串的个数，zero和one分别代表从左到右第k个字符串里的0和1的个数，对第i个字符串，可以取也可以不取,则

![4](/img/math4.PNG)

2. **计算**

对包含前i个字符串的集合，a[p][q]依赖于之前字符串数目更少的字符串集合，故<br>
外循环变量是  ``` i=0 to sizeof(a)```<br>
里面是一个双重循环：<br>
内循环I: ```p=m to zero```(m>=zero)<br>
内循环II: ```q=n to one```(n>=one)<br>
呃，这里有一个坑诶，注意p和q的初始值一定要从m,n开始，因为每执行一次外循环，zero和one是不确定的，如果我们从zero和one开始的话，某些输入序列实例可能会导致某些子问题不能够独立求解。

啊 好难理解哦，那就...举个错误的栗子叭：

{: .box-error}
假设给定的m=2, n=1, 字符串集合为{"1","0"},若我们从zero和one开始递增p,q的话：<br>
i=1时，zero=0, one=1;<br>
那么a[0][1]=1; a[1][1]=1;a[2][1]=1;<br>
//实际上a[2][1]=1;a[1][1]=1;a[0][1]=1;<br>
i=2时，zero=1, one=0;<br>
那么a[1][0]=1; a[1][1]=2;a[2][0]=2;a[2][1]=3;<br>
//实际上a[2][1]=2;a[2][0]=2;a[1][1]=2;a[1][0]=1；<br>
程序运行结束时 Output: 3<br>
//Expected: 2<br>

为什么会这样呢？我们把i=1和i=2的情况分别记为子问题P1,子问题P2;现在单独来看子问题P2；从动态规划的原理出发，我们所期待的是：P2的最优解由P1唯一确定（子问题的重叠性，即P2唯一依赖于P1和P0（P0=0）），并且P2是可独立求解的，即P2的子子问题不共享资源，互不影响（子问题的无关性）；但是在这个错误实例的运行过程中，我们看到P2的子子问题确定了a[1][1]的最优解的值为2后，P2的另一个子子问题在确定a[2][1]的最优解的值时用到了a[1][1], 但这个a[1][1]并不是我们期待的由P1确定的a[1][1]，而是被P2的子子问题改变了的a[1][1]，因此我们得到的a[2][1]也就不是由P1获得的最优解唯一确定的P2的最优解了，在建模方案上，我们就已经失败了。再看正确的案例（上面的注释环节），我们看到，每解决P2的一个子子问题，都不会影响到它的下一个子子问题的解决，这些子子问题很好地相互独立，故P2获得的最优解由P1唯一确定。

还有一种更好的理解方式是画一个类似韦恩的东西：<br>
在这个问题实例中，<br>
错误解法的子问题的最优解之间的关系是相交的，像这样：<br>
![1](/img/vein1.jpg)

正确解法的子问题的最优解之间的关系是蕴含的，像这样：
![1](/img/vein2.jpg)

啊 我要继续去踩动态规划的坑了，再见~

***

后话：这里的markdown竟然没有数学公式的扩展...只好在别的地方打出公式来截图要自闭辽~